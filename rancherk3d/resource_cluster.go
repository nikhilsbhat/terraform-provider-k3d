// ----------------------------------------------------------------------------
//
//     ***     TERRAGEN GENERATED CODE    ***    TERRAGEN GENERATED CODE     ***
//
// ----------------------------------------------------------------------------
//
//     This file was auto generated by Terragen.                                                       //nolint:gosec
//     This autogenerated code has to be enhanced further to make it fully working terraform-provider.
//
//     Get more information on how terragen works.
//     https://github.com/nikhilsbhat/terragen
//
// ----------------------------------------------------------------------------
package rancherk3d

import (
	"context"

	"github.com/hashicorp/terraform-plugin-sdk/v2/diag"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
)

func resourceCluster() *schema.Resource {
	return &schema.Resource{
		CreateContext: resourceRANCHERK3DCreate,
		ReadContext:   resourceRANCHERK3DRead,
		DeleteContext: resourceRANCHERK3DDelete,

		Schema: map[string]*schema.Schema{
			"name": {
				Type:        schema.TypeString,
				Optional:    true,
				DefaultFunc: schema.EnvDefaultFunc("K3D_CLUSTER_NAME", "k3d-cluster"),
				ForceNew:    true,
				Description: "name the cluster to be created",
			},
			"server_nos": {
				Type:        schema.TypeString,
				Optional:    true,
				DefaultFunc: schema.EnvDefaultFunc("K3D_SERVER_NOS", "1"),
				ForceNew:    true,
				Description: "number of servers you want to create",
			},
			"agent_nos": {
				Type:        schema.TypeString,
				Optional:    true,
				DefaultFunc: schema.EnvDefaultFunc("K3D_AGENTS_NOS", "1"),
				ForceNew:    true,
				Description: "number of agents you want to create",
			},
			"image": {
				Type:        schema.TypeString,
				Optional:    true,
				DefaultFunc: schema.EnvDefaultFunc("K3D_IMAGE", "rancher/k3s"),
				ForceNew:    true,
				Description: "image name to be used for creation of cluster, it would be used along with kubernetes_version",
				Computed:    true,
			},
			"network": {
				Type:        schema.TypeString,
				Optional:    true,
				ForceNew:    true,
				Description: "custom network to be used",
				Computed:    false,
			},
			"token": {
				Type:        schema.TypeString,
				Optional:    true,
				ForceNew:    true,
				Description: "superSecretToken to be used",
				Computed:    false,
			},
			"volumes": {
				Type:     schema.TypeList,
				Optional: true,
				Computed: false,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"volume": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    false,
							Description: "volume to be used",
						},
						"nodeFilters": {
							Type:     schema.TypeList,
							Optional: true,
							Computed: false,
							Elem:     &schema.Schema{Type: schema.TypeString},
						},
					},
				},
			},
			"ports": {
				Type:     schema.TypeList,
				Optional: true,
				Computed: false,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"port": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    false,
							Description: "port to be used",
						},
						"nodeFilters": {
							Type:     schema.TypeList,
							Optional: true,
							Computed: false,
							Elem:     &schema.Schema{Type: schema.TypeString},
						},
					},
				},
			},
			"labels": {
				Type:     schema.TypeList,
				Optional: true,
				Computed: false,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"label": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    false,
							Description: "label to be used",
						},
						"nodeFilters": {
							Type:     schema.TypeList,
							Optional: true,
							Computed: false,
							Elem:     &schema.Schema{Type: schema.TypeString},
						},
					},
				},
			},
			"env": {
				Type:     schema.TypeList,
				Optional: true,
				Computed: false,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"envVar": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    false,
							Description: "environment variable to be used",
						},
						"nodeFilters": {
							Type:     schema.TypeList,
							Optional: true,
							Computed: false,
							Elem:     &schema.Schema{Type: schema.TypeString},
						},
					},
				},
			},
			"registries": {
				Type:     schema.TypeSet,
				Optional: true,
				Computed: false,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"create": {
							Type:        schema.TypeBool,
							Optional:    true,
							Computed:    false,
							Description: "creates a default registry to be used with the cluster",
						},
						"use": {
							Type:        schema.TypeList,
							Optional:    true,
							Computed:    false,
							Elem:        &schema.Schema{Type: schema.TypeString},
							Description: "some other k3d-managed registry",
						},
						"config": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    false,
							Description: "define contents of the `registries.yaml` file (or reference a file); same as `--registry-config /path/to/config.yaml`",
						},
					},
				},
			},
			"options": {
				Type:     schema.TypeSet,
				Optional: true,
				Computed: false,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"k3d": {
							Type:        schema.TypeMap,
							Optional:    true,
							Computed:    false,
							Elem:        &schema.Schema{Type: schema.TypeString},
							Description: "runtime settings to be passed to k3d",
						},
						"k3s": {
							Type:        schema.TypeMap,
							Optional:    true,
							Computed:    false,
							Elem:        &schema.Schema{Type: schema.TypeList},
							Description: "options to be passed on to K3s itself",
						},
						"kubeconfig": {
							Type:        schema.TypeMap,
							Optional:    true,
							Computed:    false,
							Elem:        &schema.Schema{Type: schema.TypeString},
							Description: "operations to be performed with kubeconfig once cluster is created",
						},
						"runtime": {
							Type:        schema.TypeMap,
							Optional:    true,
							Computed:    false,
							Elem:        &schema.Schema{Type: schema.TypeString},
							Description: "runtime (docker) specific options",
						},
					},
				},
			},
		},
	}
}

func resourceRANCHERK3DCreate(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics {
	// Your code goes here
	return nil
}

func resourceRANCHERK3DRead(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics {
	// Your code goes here
	return nil
}

func resourceRANCHERK3DDelete(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics {
	// Your code goes here
	return nil
}
